package com.kanven.jdbc.plus.statement;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import com.google.common.base.Function;
import com.google.common.collect.Lists;
import com.kanven.jdbc.plus.util.MethodSafeInvoker;
import com.kanven.jdbc.plus.util.ThrowExceptionMethodInvoker;

public abstract class AbstractStatementAdapter<T extends Statement> extends
		AbstractUnsupportStatamentAdapter {

	private boolean closed;

	private boolean poolable;

	private int queryTimeout;

	private int fetchSize = -1;

	private int maxRows = -1;

	private int maxFieldSize = -1;

	protected boolean escapeProcessing;

	protected String cursorName;

	private int resultSetType;

	private int resultSetConcurrency;

	private int resultSetHoldability;

	private List<BackendStatementWrapper<T>> wrappers = new ArrayList<BackendStatementWrapper<T>>();

	public AbstractStatementAdapter() {

	}

	public AbstractStatementAdapter(int resultSetType, int resultSetConcurrency) {
		this.resultSetType = resultSetType;
		this.resultSetConcurrency = resultSetConcurrency;
	}

	public AbstractStatementAdapter(int resultSetType,
			int resultSetConcurrency, int resultSetHoldability) {
		this(resultSetType, resultSetConcurrency);
		this.resultSetHoldability = resultSetHoldability;
	}

	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		return getStatement(sql).getStatement().executeUpdate(sql,
				autoGeneratedKeys);
	}

	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		return getStatement(sql).getStatement().executeUpdate(sql,
				columnIndexes);
	}

	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		return getStatement(sql).getStatement().executeUpdate(sql, columnNames);
	}

	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		return getStatement(sql).getStatement().execute(sql, autoGeneratedKeys);
	}

	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return getStatement(sql).getStatement().execute(sql, columnIndexes);
	}

	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		return getStatement(sql).getStatement().execute(sql, columnNames);
	}

	public ResultSet executeQuery(String sql) throws SQLException {
		return getStatement(sql).getStatement().executeQuery(sql);
	}

	public int executeUpdate(String sql) throws SQLException {
		return getStatement(sql).getStatement().executeUpdate(sql);
	}

	public boolean execute(String sql) throws SQLException {
		return getStatement(sql).getStatement().execute(sql);
	}

	public ResultSet getResultSet() throws SQLException {
		Collection<T> sts = getStatements();
		for (Statement st : sts) {
			ResultSet rs = st.getResultSet();
			if (rs != null) {
				return rs;
			}
		}
		return null;
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		getMasterStatement().getStatement().addBatch(sql);
	}

	@Override
	public int[] executeBatch() throws SQLException {
		return getMasterStatement().getStatement().executeBatch();
	}

	@Override
	public void clearBatch() throws SQLException {
		getMasterStatement().getStatement().clearBatch();
	}

	protected Collection<T> getStatements() {
		return Lists.transform(wrappers,
				new Function<BackendStatementWrapper<T>, T>() {
					public T apply(BackendStatementWrapper<T> backend) {
						return backend.getStatement();
					}
				});
	}

	protected void addWrapper(BackendStatementWrapper<T> wrapper) {
		this.wrappers.add(wrapper);
	}

	protected List<BackendStatementWrapper<T>> getWrappers() {
		return this.wrappers;
	}

	protected void clearStatements() {
		wrappers.clear();
	}

	protected abstract BackendStatementWrapper<T> getMasterStatement()
			throws SQLException;

	protected abstract BackendStatementWrapper<T> getStatement(String sql)
			throws SQLException;

	public final int getMaxFieldSize() throws SQLException {
		return maxFieldSize;
	}

	public final void setMaxFieldSize(final int max) throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.setMaxFieldSize(max);
					}
				});
		this.maxFieldSize = max;
	}

	public final int getMaxRows() throws SQLException {
		return this.maxRows;
	}

	public final void setMaxRows(final int max) throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.setMaxRows(max);
					}
				});
		this.maxRows = max;
	}

	public final void setEscapeProcessing(final boolean enable)
			throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.setEscapeProcessing(enable);
					}
				});
		this.escapeProcessing = enable;
	}

	public final int getQueryTimeout() throws SQLException {
		return queryTimeout;
	}

	public final void setQueryTimeout(final int seconds) throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.setQueryTimeout(seconds);
					}
				});
		this.queryTimeout = seconds;
	}

	public final void cancel() throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.cancel();
					}
				});
	}

	public final SQLWarning getWarnings() throws SQLException {
		return null;
	}

	public final void clearWarnings() throws SQLException {

	}

	public final void setCursorName(final String name) throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.setCursorName(name);
					}
				});
		this.cursorName = name;
	}

	public final int getUpdateCount() throws SQLException {
		long result = -1;
		for (Statement st : getStatements()) {
			int count = st.getUpdateCount();
			if (count > 0) {
				result += count;
			}
		}
		if (result > Integer.MAX_VALUE) {
			result = Integer.MAX_VALUE;
		}
		return Long.valueOf(result).intValue();
	}

	// 存储过程使用，不处理
	public final boolean getMoreResults() throws SQLException {
		return false;
	}

	// 存储过程使用，不处理
	public final boolean getMoreResults(int current) throws SQLException {
		return false;
	}

	public final void setFetchDirection(int direction) throws SQLException {
		// 不做任何处理
	}

	public final int getFetchDirection() throws SQLException {
		return ResultSet.FETCH_FORWARD;
	}

	public final void setFetchSize(final int rows) throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.setFetchSize(rows);
					}
				});
		this.fetchSize = rows;
	}

	public final int getFetchSize() throws SQLException {
		return fetchSize;
	}

	public final void close() throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						if (!st.isClosed()) {
							st.close();
						}
					}
				});
		clearStatements();
		closed = true;
	}

	public final boolean isClosed() throws SQLException {
		return closed;
	}

	public final void setPoolable(final boolean poolable) throws SQLException {
		MethodSafeInvoker.invoke(getStatements(),
				new ThrowExceptionMethodInvoker<T>() {
					public void invoke(T st) throws SQLException {
						st.setPoolable(poolable);
					}
				});
		this.poolable = poolable;
	}

	public final boolean isPoolable() throws SQLException {
		return poolable;
	}

	public int getResultSetConcurrency() throws SQLException {
		return resultSetConcurrency;
	}

	public int getResultSetType() throws SQLException {
		return resultSetType;
	}

	public int getResultSetHoldability() throws SQLException {
		return resultSetHoldability;
	}

}
