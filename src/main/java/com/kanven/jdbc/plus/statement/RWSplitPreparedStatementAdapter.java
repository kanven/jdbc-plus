package com.kanven.jdbc.plus.statement;

import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import com.kanven.jdbc.plus.conn.ConnectionContext;

public class RWSplitPreparedStatementAdapter extends
		AbtractPreparedStatementAdapter {

	private ConnectionContext context;

	private String sql;

	private int autoGeneratedKeys;

	private int[] columnIndexes;

	private String[] columnNames;

	private static ThreadLocal<BackendStatementWrapper<PreparedStatement>> local = new ThreadLocal<BackendStatementWrapper<PreparedStatement>>();

	public RWSplitPreparedStatementAdapter(ConnectionContext context, String sql) {
		super();
		this.context = context;
		this.sql = sql;
	}

	public RWSplitPreparedStatementAdapter(ConnectionContext context,
			String sql, int resultSetType, int resultSetConcurrency) {
		super(resultSetType, resultSetConcurrency);
		this.context = context;
		this.sql = sql;
	}

	public RWSplitPreparedStatementAdapter(ConnectionContext context,
			String sql, int resultSetType, int resultSetConcurrency,
			int resultSetHoldability) {
		super(resultSetType, resultSetConcurrency, resultSetHoldability);
		this.context = context;
		this.sql = sql;
	}

	public RWSplitPreparedStatementAdapter(ConnectionContext context,
			String sql, int autoGeneratedKeys) {
		this(context, sql);
		this.autoGeneratedKeys = autoGeneratedKeys;
	}

	public RWSplitPreparedStatementAdapter(ConnectionContext context,
			String sql, int[] columnIndexes) {
		this(context, sql);
		this.columnIndexes = columnIndexes;
	}

	public RWSplitPreparedStatementAdapter(ConnectionContext context,
			String sql, String[] columnNames) {
		this(context, sql);
		this.columnNames = columnNames;
	}

	public ResultSet executeQuery() throws SQLException {
		return getStatement(sql).getStatement().executeQuery();
	}

	public int executeUpdate() throws SQLException {
		return getStatement(sql).getStatement().executeUpdate();
	}

	public boolean execute() throws SQLException {
		return getStatement(sql).getStatement().execute();
	}

	public Connection getConnection() throws SQLException {
		return context.getConnection();
	}

	public void addBatch() throws SQLException {
		BackendStatementWrapper<PreparedStatement> backend = getStatement(sql);
		if (!backend.isBelong(context.master())) {
			throw new SQLException(
					"data source is not master,cann't use batch operation.");
		}
		backend.getStatement().addBatch();
	}

	public void clearParameters() throws SQLException {
		getParams().clear();
		BackendStatementWrapper<PreparedStatement> backend = getStatement(sql);
		backend.getStatement().clearParameters();
	}

	@Override
	protected BackendStatementWrapper<PreparedStatement> getStatement(String sql)
			throws SQLException {
		BackendStatementWrapper<PreparedStatement> backend = local.get();
		if (backend == null) {
			Connection connection = context.getConnection(sql);
			if (autoGeneratedKeys > 0) {
				return new BackendStatementWrapper<PreparedStatement>(
						connection.prepareStatement(sql, autoGeneratedKeys));
			}
			if (columnIndexes != null) {
				return new BackendStatementWrapper<PreparedStatement>(
						connection.prepareStatement(sql, columnIndexes));
			}
			if (columnNames != null) {
				return new BackendStatementWrapper<PreparedStatement>(
						connection.prepareStatement(sql, columnNames));
			}
			backend = new BackendStatementWrapper<PreparedStatement>(
					connection.prepareStatement(sql));
			local.set(backend);
		}
		PreparedStatement st = backend.getStatement();
		st.clearParameters();
		try {
			getParams().replay(st);
		} catch (IllegalAccessException e) {
			throw new SQLException("params replay error.");
		} catch (IllegalArgumentException e) {
			throw new SQLException("params replay error.");
		} catch (InvocationTargetException e) {
			throw new SQLException("params replay error.");
		}
		return backend;
	}

	@Override
	protected void clearStatements() {
	}

	@Override
	protected BackendStatementWrapper<PreparedStatement> getMasterStatement()
			throws SQLException {
		BackendStatementWrapper<PreparedStatement> backend = getStatement(sql);
		if (backend.isBelong(context.master())) {
			return backend;
		}
		throw new SQLException(
				"data source is not master,cann't use batch operation.");
	}
}
